package com.ortoped.sbom

import com.ortoped.model.ScanResult
import io.github.oshai.kotlinlogging.KotlinLogging
import java.time.Instant
import java.time.ZoneOffset
import java.time.format.DateTimeFormatter

private val logger = KotlinLogging.logger {}

/**
 * SPDX SBOM generator (simplified JSON implementation)
 *
 * Note: This is a simplified implementation that generates SPDX 2.3 JSON format
 * using string templates. A future version may integrate with the full SPDX library.
 */
class SpdxGenerator : SbomGenerator {

    override fun supportedFormats(): List<SbomFormat> = listOf(
        SbomFormat.SPDX_JSON
    )

    override fun generate(scanResult: ScanResult, config: SbomConfig): String {
        logger.info { "Generating ${config.format.displayName} SBOM for ${scanResult.projectName}" }

        if (config.format !in supportedFormats()) {
            logger.warn { "SPDX Tag-Value format not yet implemented, falling back to JSON" }
        }

        val documentId = java.util.UUID.randomUUID().toString()
        val timestamp = formatSpdxTimestamp(scanResult.scanDate)

        val creators = buildList {
            add("Tool: ${config.toolName}-${config.toolVersion}")
            if (scanResult.aiEnhanced) {
                add("Tool: OrtoPed-AI-LicenseResolver")
            }
        }

        val packages = scanResult.dependencies.joinToString(",\n    ") { dep ->
            buildPackageJson(dep, config.includeAiSuggestions)
        }

        return """
{
  "spdxVersion": "SPDX-2.3",
  "dataLicense": "CC0-1.0",
  "SPDXID": "SPDXRef-DOCUMENT",
  "name": "${escape(scanResult.projectName)}-sbom",
  "documentNamespace": "https://ortoped.dev/spdx/$documentId",
  "creationInfo": {
    "created": "$timestamp",
    "creators": [${creators.joinToString(", ") { "\"$it\"" }}],
    "licenseListVersion": "3.21",
    "comment": "Generated by OrtoPed SBOM Generator"
  },
  "packages": [
    $packages
  ]
}
        """.trimIndent()
    }

    private fun buildPackageJson(
        dependency: com.ortoped.model.Dependency,
        includeAiSuggestions: Boolean
    ): String {
        val spdxId = SbomMapper.toSpdxId(dependency.id)
        val purl = SbomMapper.toPurl(dependency.id)
        val license = SbomMapper.toSpdxExpression(
            dependency.concludedLicense,
            dependency.aiSuggestion
        )
        val declaredLicense = dependency.declaredLicenses.firstOrNull() ?: "NOASSERTION"

        val annotations = if (includeAiSuggestions && dependency.aiSuggestion != null) {
            val suggestion = dependency.aiSuggestion
            val comment = buildString {
                appendLine("AI License Suggestion:")
                appendLine("  Suggested License: ${suggestion.suggestedLicense}")
                appendLine("  Confidence: ${suggestion.confidence}")
                suggestion.spdxId?.let { appendLine("  SPDX ID: $it") }
                appendLine("  Reasoning: ${suggestion.reasoning}")
                if (suggestion.alternatives.isNotEmpty()) {
                    appendLine("  Alternatives: ${suggestion.alternatives.joinToString(", ")}")
                }
            }.trim()

            """,
    "annotations": [{
      "annotationType": "REVIEW",
      "annotator": "Tool: OrtoPed-AI-LicenseResolver",
      "annotationDate": "${formatSpdxTimestamp(Instant.now().toString())}",
      "comment": "${escape(comment)}"
    }]"""
        } else {
            ""
        }

        return """
{
      "SPDXID": "$spdxId",
      "name": "${escape(dependency.name)}",
      "versionInfo": "${escape(dependency.version)}",
      "downloadLocation": "NOASSERTION",
      "filesAnalyzed": false,
      "licenseConcluded": "$license",
      "licenseDeclared": "$declaredLicense",
      "copyrightText": "NOASSERTION",
      "externalRefs": [{
        "referenceCategory": "PACKAGE-MANAGER",
        "referenceType": "purl",
        "referenceLocator": "$purl"
      }]$annotations
    }"""
    }

    private fun escape(str: String): String {
        return str.replace("\\", "\\\\")
            .replace("\"", "\\\"")
            .replace("\n", "\\n")
            .replace("\r", "\\r")
            .replace("\t", "\\t")
    }

    private fun formatSpdxTimestamp(isoTimestamp: String): String {
        return try {
            val instant = Instant.parse(isoTimestamp)
            DateTimeFormatter.ofPattern("yyyy-MM-dd'T'HH:mm:ss'Z'")
                .withZone(ZoneOffset.UTC)
                .format(instant)
        } catch (e: Exception) {
            DateTimeFormatter.ofPattern("yyyy-MM-dd'T'HH:mm:ss'Z'")
                .withZone(ZoneOffset.UTC)
                .format(Instant.now())
        }
    }
}
